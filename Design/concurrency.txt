Message passing 
    - a form of communication used in concurrent computing, parallel computing, object-oriented programming, and interprocess communication. 
    - By waiting for messages, processes can also synchronize.

Thread or process synchronization [or serialization]
    - the application of particular mechanisms to ensure that two concurrently-executing threads or processes do not execute specific portions of a program at the same time. 
    - If one thread has begun to execute a serialized portion of the program, any other thread trying to execute this portion must wait until the first thread finishes. 
    - Synchronization is used to control access to state both in small-scale multiprocessing systems and in distributed computers
        * in banking and database systems, in web servers, and so on.

Lock:
    - a lock is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution. 
    - A lock is designed to enforce a mutual exclusion concurrency control policy.
    - Generally, locks are advisory locks, where each thread cooperates by acquiring the lock before accessing the corresponding data. 
        * there are also mandatory locks, where attempting unauthorized access to a locked resource will force an exception in the entity attempting to make the access.
    - A (binary) semaphore is the simplest type of lock
    - Locks typically require hardware support for efficient implementation. 
      These instructions allow a single process to test if the lock is free, and if free, acquire the lock in a single atomic operation.
      This support usually takes the form of one or more atomic instructions. 
        Example: "test-and-set", "fetch-and-add" or "compare-and-swap" (CAS).

Disadvantage of locks:
    - Lock-based resource protection and thread/process synchronization have many disadvantages:
        * Cause blocking, which means some threads/processes have to wait until a lock (or a whole set of locks) is released.
        * Lock handling adds overhead for each access to a resource, even when the chances for collision are very rare. (However, any chance for such collisions is a race condition.)
        * Locks can be vulnerable to failures and faults that are often very subtle and may be difficult to reproduce reliably. 
            - One example is the deadlock, where (at least) two threads each hold a lock that the other thread holds and will not give up until it has acquired the other lock.
        * If one thread holding a lock dies, stalls/blocks or goes into any sort of infinite loop, other threads waiting for the lock may wait forever.
        * Lock contention limits scalability and adds complexity.
        * Priority inversion. High priority threads/processes cannot proceed, if a low priority thread/process is holding the common lock.
        * Convoying. All other threads have to wait, if a thread holding a lock is descheduled due to a time-slice interrupt or page fault.
        * Hard to debug: Bugs associated with locks are time dependent. They are extremely hard to replicate.

Funnel
    - a funnel is a synchronization primitive used in kernel development to protect system resources.
    - A funnel is a mutex that prevents more than one thread from accessing certain kernel resources at the same time.
    - Funnels are now used in the Mac OS X kernel
    - Each thread acquires a funnel when it enters a synchronized portion of the kernel, and releases it when it leaves. 
        * If a thread blocks (sleeps) while holding a funnel, the kernel forces the thread to automatically drop the funnel, thereby allowing other threads to enter the synchronized portion of the kernel.

Serializing tokens
    -  a concept in concurrency control arising from the ongoing development of DragonFly BSD
    - Tokens are similar to mutexes in that they can, if used correctly, prevent multiple threads from accessing a shared resource at the same time. 
      Unlike mutexes, however, they do NOT exclude other threads from accessing the resource while they are blocked or asleep. 
    
Spinlock
    - A spinlock is a lock where the thread simply waits ("spins") until the lock becomes available. 
    - Pro: very efficient if threads are only likely to be blocked for a short period of time, as it avoids the overhead of operating system process re-scheduling. 
    - Con: It is wasteful if the lock is held for a long period of time.

Race Condition
    - anything where the outcome depends on the relative ordering of execution of operations on two or more threads
        * timing sensitive
    - race conditions typically occur where completing an operation requires modification of two or more distinct pieces of data
        * such as the two link pointers in the linked list. 
    - Because the operation must access two separate pieces of data, these must be modified in separate instructions
      and another thread could potentially access the data structure when only one of them has been completed

Avoid race condition
    - Option 1: (simplest: locking & mutex)
        * wrap your data structure with a protection mechanism
        * ensure that only the thread actually performing a modification can see the intermediate states
    - Option 2: (lock-free programming)
        * modify the design of your data structure
    - Option 3:  software transactional memory (STM)
        * handle the updates to the data structure as a transaction
        * just as updates to a database are done within a transaction.
        * The required series of data modifications and reads is stored in a transaction log and then committed in a single step.

Mutex in C++0x
    - basic operations
        * create a mutex by constructing an instance of std::mutex, 
        * lock: call member function lock()
        * unlock: call member function unlock(). 
    - *** NOT recommended practice to call the member functions directly
        - because this means that you have to remember to call unlock() on every code path out of a function, 
          including those due to exceptions. 
    - STL provides the std::lock_guard class template, which implements that RAII idiom for a mutex; 
        * it locks the supplied mutex on construction and unlocks it on destruction, 
          thus ensuring a locked mutex is always correctly unlocked. 

Mutex
    - Majority of cases: group the mutex and the protected data together in a class 
        * rather than use global variables. 

System call 
    - how a program requests a service from an operating system's kernel. 
    - This may include hardware related services (e.g. accessing the hard disk), creating and executing new processes, and communicating with integral kernel services (like scheduling). 
    - System calls provide an essential interface between a process and the operating system.
