Suffix tree
	- a compressed trie containing all the suffixes of the given string.
	- it means I could determine if the word BANANAS was in the collected works of William Shakespeare by performing just 7 character comparisons. 
	  * Of course, we also need to consider the time to construct the trie.

Suffix tree construction:
	- Linear suffix tree construction by *path compression* (Ukkonen's algorithm) 
		- Starts with an empty tree, then progressively adds each of the N prefixes of T to the suffix tree. 
			* For example, when creating the suffix tree for BANANAS, B is inserted into the tree, then BA, then BAN, and so on. When BANANAS is finally inserted, the tree is complete.
		- constructing one requires O(N) time and space
	- *path compression* 
		- individual edges in the tree now may represent sequences of text instead of single characters.
	- the reduction in the number of nodes by path compression leads to 
		* the time and space requirements for constructing a suffix tree are reduced from O(N^2) to O(N)
	- Worst case, a suffix tree can be built with a maximum of 2N nodes, where N is the length of the input text.

Ukkonen's algorithm: Linear Suffix tree construction
	// http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english?rq=1
	// http://marknelson.us/1996/08/01/suffix-trees/
	- Algorithm begins with an implicit suffix tree containing the first character of the string. Then it steps through the string adding successive characters until the tree is complete. 
	* Example: 
		- when creating the suffix tree for BANANAS, 
		    * insert_to_tree("B") 
		    * insert_to_tree("BA")
		    * insert_to_tree("BAN") and so on. 
		    * When "BANANAS" is finally inserted, the tree is complete.
	- This order addition of characters gives Ukkonen's algorithm its "on-line" property.

		
Trie
	- A trie is a type of tree that has N possible branches from each node, where N is the number of characters in the alphabet. 

T-tree
	- a type of binary tree data structure that is widely used by main-memory databases
		* such as Datablitz, EXtremeDB, MySQL Cluster, Oracle TimesTen and MobileLite
	- T-tree is a balanced index tree data structure optimized for cases where both the index and the actual data are fully kept in memory
	- T-trees do not keep copies of the indexed data fields within the index tree nodes themselves. 
	  ** Instead, they take advantage of the fact that the actual data is always in main memory together with the index 
	     so that they just contain pointers to the actual data fields.
	- 'T' refers to the shape of the node data structures in the original paper that first described this type of index.

T_Node	{
	T_Node* parent;
	T_Node* left;
	T_Node* right;
	
	data[1...N];		// kepted in sorted order
	min_data_in_arr;
	max_data_in_arr;
}

k-d tree (short for k-dimensional tree) 
	- a space-partitioning data structure for organizing points in a k-dimensional space. 
	- k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches). 
	- k-d trees are a special case of binary space partitioning trees.

T-tree's balance
	- T-tree balanced like an AVL tree
	- it becomes out of balance when a node's child trees differ in height by at least two levels. This can happen after an insertion or deletion of a node. After an insertion or deletion, the tree is scanned from the leaf to the root. If an imbalance is found, one tree rotation or pair of rotations is performed, which is guaranteed to balance the whole tree.

B-Tree vs T-Tree
	- B-tree is an index structure optimized for storage on block oriented secondary storage devices like hard disks. 
	- T-trees seek to gain the performance benefits of in-memory tree structures such as AVL trees while avoiding the large storage space overhead which is common to them.

AVL tree (Adelson-Velskii and Landis' tree, named after the inventors) 
	- a self-balancing binary search tree
	- was the first such data structure to be invented.
	- In an AVL tree, the heights of the two child subtrees of any node differ by at most one
		* if at any time they differ by more than one, rebalancing is done to restore this property.
	- Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases (n: number of nodes)

AVL tree vs Red-black tree
	- AVL trees are often compared with red-black trees because both support the same set of basic operations and take O(log n) time
	- Both AVL trees and red-black trees are self-balancing binary search trees and they are very similar mathematically.
	- AVL trees are more rigidly balanced than red-black trees, leading to slower insertion and removal but faster retrieval.
	- For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced.
	- Similar to red-black trees, AVL trees are height-balanced but in general not weight-balanced
		* sibling nodes can have hugely differing numbers of descendants.

splay tree 
	- a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again. 
	- It performs basic operations such as insertion, look-up and removal in O(log n) amortized time.
	- Frequently accessed nodes will move nearer to the root where they can be accessed more quickly. 
	- When a node x is accessed, a splay operation is performed on x to move it to the root.
	

Disjoint set:
	- two sets are disjoint if they have no element in common. 
	- For example, {1, 2, 3} and {4, 5, 6} are disjoint sets.
	- A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. 

Union-Find algorithm
	- an algorithm that performs two useful operations on such a data structure
	- Find: 
		* Determine which subset a particular element is in. 
		* This can be used for determining if two elements are in the same subset.
	- Union: 
		* Join two subsets into a single subset.

threaded binary tree
	- "A binary tree is threaded
		* all right child pointers that would normally be null point to the inorder successor of the node
		* all left child pointers that would normally be null point to the inorder predecessor of the node."
	- Pro: 
		1. makes the tree traversal a linear traversal
			* more rapid than a recursive in-order traversal. 
		2. Easier to discover the parent of a node from a threaded binary tree
			* without explicit use of parent pointers or a stack, albeit slowly
			* This can be useful where stack space is limited, or where a stack of parent pointers is unavailable 
			(for finding the parent pointer via DFS).

Graph traversal:
    - Two main ways to traverse the graph:
        * Breadth-first
            - require a queue
            - how it works:
                * as we pop a node off the queue, we copy each of its neighbors, and push them to the queue.
        * Depth-first

Graph basics:
    - directed / undirected

n&(n-1)
    - it will be 0 if it's 1, 2, 4, 8, 16, 32 (2^0, 2^1, 2^2 ....)
 
 AVL tree (Adelson-Velskii and Landis' tree, named after the inventors) 
	- self-balancing binary search tree
	- In an AVL tree, the heights of the two child subtrees of any node differ by at most one 
	- if at any time they differ by more than one, rebalancing is done to restore this property. 
	- Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation.	
	- insertions and deletions may require the tree to be rebalancled by one or more tree rotations.
	- For each node checked, if the balance factor remains -1, 0, or +1 then no rotations are necessary. 
	  However, if balance factor becomes less than -1 or greater than +1, the subtree rooted at this node is unbalanced.

AVL tree vs. red-black tree
	- similarity:
		* both support the same set of operations and take O(log n) time for the basic operations. 
		* both are height-balanced, not weight balanced
	- Diff:
		* For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced

Binary Tree vs Binary Search Tree
    - Binary tree:
        * a tree data structure in which each node has at most two child nodes, 
    - Binary Search Tree:
        * binary search tree (BST) (sometimes also called an ordered or sorted binary tree)
            - The left subtree of a node contains only nodes with keys less than the node's key.
            - The right subtree of a node contains only nodes with keys greater than the node's key.
            - The left and right subtree must each also be a binary search tree.
            - There must be no duplicate nodes.

How to balance the tree:
	- tree rotation is an operation on a binary tree that changes the structure without interfering with the order of the elements. 
	- balanceFactor = height(left-subtree) - height(right-subtree). 
